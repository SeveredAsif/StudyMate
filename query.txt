 --npm install -y express
--npm install express multer
--npm install pg-promise


CREATE DATABASE studymate;

CREATE TABLE Student (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    age INTEGER,
    enrollment_date DATE,
    password_hash VARCHAR(255), 
    creation_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO student (
        first_name,
        last_name,
        age,
        enrollment_date,
        password_hash
    )
VALUES (
        'ASIF',
        'KHAN',
        22,
        '2024-01-07',
        'hashed_password'
    );
	
	
	

-- Create the teacher table
CREATE TABLE Teacher (
    teacher_id SERIAL PRIMARY KEY,
   -- Assuming user_id is a foreign key referencing the user table
    teacher_name VARCHAR(255),
    teacher_proficiency VARCHAR(255),
    teacher_birth_date DATE,
    age INTEGER,
    initiated_courses_name VARCHAR(255),
    last_uploaded TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     password_hash VARCHAR(255)
);
-- Create a function to calculate age and update the age field
CREATE OR REPLACE FUNCTION update_teacher_age() RETURNS TRIGGER AS $$ BEGIN NEW.age = EXTRACT(
        YEAR
        FROM age(NEW.teacher_birth_date)
    );
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- Create a trigger to call the function before insert or update
CREATE TRIGGER before_insert_or_update_teacher BEFORE
INSERT
    OR
UPDATE ON teacher FOR EACH ROW EXECUTE FUNCTION update_teacher_age();
-- Update the trigger to set teacher_id from user_id
CREATE OR REPLACE FUNCTION set_teacher_id() RETURNS TRIGGER AS $$ BEGIN IF NEW.teacher_id IS NULL THEN NEW.teacher_id := NEW.user_id;
END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- Create a new trigger to set teacher_id before insert
CREATE TRIGGER before_insert_teacher_set_id BEFORE
INSERT ON teacher FOR EACH ROW EXECUTE FUNCTION set_teacher_id();
-- Insert data into the teacher table without specifying initiated_courses_name
INSERT INTO teacher (
       teacher_id,
        teacher_name,
        teacher_proficiency,
        teacher_birth_date,password_hash
    )
VALUES (1, 'John Doe', 'Mathematics', '1990-05-15','1'),
    (2, 'Jane Smith', 'Physics', '1985-09-22','2');
-- The rest of the fields (age, last_uploaded) will be automatically updated by TRIGGER
CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    course_title VARCHAR(255) NOT NULL,
    course_description TEXT,
    creation_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    course_creator VARCHAR(255) NOT NULL,
    enrolled_id INTEGER REFERENCES student(student_id),
    update_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
   teacher_id INTEGER REFERENCES teacher(teacher_id) -- Adding teacher reference
);
CREATE TABLE enrollments (
    enrollment_id SERIAL PRIMARY KEY,
    student_id INTEGER REFERENCES student(student_id),
    course_id INTEGER REFERENCES courses(id),
    enrollment_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE watched (
    watched_id SERIAL PRIMARY KEY,
    student_id INTEGER REFERENCES student(student_id),
    lecture_id INTEGER REFERENCES Lecture(lecture_id),
    watched_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Lecture (
    lecture_id SERIAL PRIMARY KEY,
    description TEXT,
    pdf_note BYTEA,
    lecture_name VARCHAR(255),
    video BYTEA,
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Added timestamp for the time of upload
    teacher_id INTEGER REFERENCES teacher(teacher_id), -- Assuming there's a Teacher table with teacher_id
    course_id INTEGER REFERENCES courses(id), -- Assuming there's a Course table with course_id
);


ALTER TABLE LECTURE
DROP COLUMN COURSE_ID;

ALTER TABLE Lecture
ADD COLUMN course_id INTEGER REFERENCES courses(id),
ADD CONSTRAINT fk_lecture_course
FOREIGN KEY (course_id) REFERENCES courses(id);

CREATE TABLE TOPIC (
    topic_id SERIAL PRIMARY KEY,
    topic_name VARCHAR(255) NOT NULL
);

CREATE TABLE exam_section (
    id SERIAL PRIMARY KEY,
    exam_topic VARCHAR(255) NOT NULL,
    question_id INTEGER NOT NULL
);

CREATE TABLE question (
    id SERIAL PRIMARY KEY,
    question_statement TEXT NOT NULL
);

CREATE TABLE answer (
    id SERIAL PRIMARY KEY,
    ans_statement TEXT NOT NULL,
    explanation TEXT
);

CREATE TABLE choice (
    id SERIAL PRIMARY KEY,
    option_text TEXT NOT NULL
);

CREATE TABLE feedback (
    feedback_serial SERIAL PRIMARY KEY,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    comment TEXT
);

CREATE TABLE lecture_progress (
    lecture_progress_id SERIAL PRIMARY KEY,
    current_id INTEGER REFERENCES lecture(lecture_id),
    finished_id INTEGER REFERENCES lecture(lecture_id)
);

CREATE TABLE exam_performance (
    exam_id SERIAL PRIMARY KEY,
    accuracy_pct DECIMAL(5, 2), -- Assuming accuracy percentage can have two decimal places
    avg_time_per_question INTEGER -- Assuming average time is measured in seconds
);

CREATE TABLE tracking_section (
    track_id SERIAL PRIMARY KEY,
    exam_performance_id INTEGER REFERENCES exam_performance(exam_id),
    lecture_progress_id INTEGER REFERENCES lecture_progress(lecture_progress_id)
);


CREATE TABLE to_do_list (
    id SERIAL PRIMARY KEY,
    task_name VARCHAR(255) NOT NULL
);

CREATE TABLE routine (
    id SERIAL PRIMARY KEY,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    task_name VARCHAR(255) NOT NULL
);

CREATE TABLE study_info (
    id SERIAL PRIMARY KEY,
    routine_id INTEGER REFERENCES routine(id),
    todo_list_id INTEGER REFERENCES to_do_list(id),
    study_hour INTEGER REFERENCES study_hour(id)
);

CREATE TABLE study_hour (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    hours_studied INTEGER NOT NULL,
    study_info_id INTEGER REFERENCES study_info(id)
);

CREATE TABLE guideline_giver (
    guide_id SERIAL PRIMARY KEY,
    proficiency VARCHAR(255) NOT NULL,
    phone_no VARCHAR(15) NOT NULL,
    university VARCHAR(255) NOT NULL
);

alter table answer add column question_id INTEGER REFERENCES question(id);
alter table question add column exam_id INTEGER REFERENCES exam_section(id);
alter table exam_section add column topic_id INTEGER REFERENCES TOPIC(topic_id);
alter table choice add column question_id INTEGER REFERENCES question(id);
alter table courses add column rate_id INTEGER REFERENCES feedback(feedback_serial);
alter table feedback add column student_id INTEGER REFERENCES student(student_id);

-- Add a new table to represent the guidance relationship
CREATE TABLE guidance (
    guidance_id SERIAL PRIMARY KEY,
    guide_id INTEGER REFERENCES guideline_giver(guide_id),
    student_id INTEGER REFERENCES student(student_id),
    guidance_start_date DATE,
    guidance_end_date DATE
);

-- Add a foreign key constraint to ensure that each student is guided by only one guideline giver at a time
-- If a student can be guided by multiple guideline givers simultaneously, you may need to adjust this constraint
ALTER TABLE guidance
ADD CONSTRAINT unique_guidance_for_student
UNIQUE (student_id);

CREATE TABLE forum (
    post_id SERIAL PRIMARY KEY,
    student_id INTEGER REFERENCES student(student_id),
    post_content TEXT,
    post_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE discussion (
    discussion_id SERIAL PRIMARY KEY,
    forum_post_id INTEGER REFERENCES forum(post_id),
    reply_giver_id INTEGER,
    reply_giver_type VARCHAR(20), -- This field can indicate whether the reply giver is a 'student', 'teacher', or 'guideline_giver'
    reply_content TEXT,
    reply_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Add a foreign key constraint for the reply giver
-- Create a table for reply givers
CREATE TABLE reply_givers (
    reply_giver_id INTEGER PRIMARY KEY,
    reply_giver_type VARCHAR(20) NOT NULL
);

-- Add a unique constraint to the reply_givers table
ALTER TABLE reply_givers
ADD CONSTRAINT uq_reply_givers_id_type UNIQUE (reply_giver_id, reply_giver_type);


-- Add a foreign key constraint for the reply giver
ALTER TABLE discussion
ADD CONSTRAINT fk_reply_giver
FOREIGN KEY (reply_giver_id, reply_giver_type) 
REFERENCES reply_givers(reply_giver_id, reply_giver_type);






-- Add a new table to represent the guidance relationship
CREATE TABLE guidance (
    guidance_id SERIAL PRIMARY KEY,
    guide_id INTEGER REFERENCES guideline_giver(guide_id),
    student_id INTEGER REFERENCES student(student_id),
    guidance_start_date DATE,
    guidance_end_date DATE
);

-- Add a foreign key constraint to ensure that each student is guided by only one guideline giver at a time
-- If a student can be guided by multiple guideline givers simultaneously, you may need to adjust this constraint
ALTER TABLE guidance
ADD CONSTRAINT unique_guidance_for_student
UNIQUE (student_id);

CREATE TABLE forum (
    post_id SERIAL PRIMARY KEY,
    student_id INTEGER REFERENCES student(student_id),
    post_content TEXT,
    post_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE discussion (
    discussion_id SERIAL PRIMARY KEY,
    forum_post_id INTEGER REFERENCES forum(post_id),
    reply_giver_id INTEGER,
    reply_giver_type VARCHAR(20), -- This field can indicate whether the reply giver is a 'student', 'teacher', or 'guideline_giver'
    reply_content TEXT,
    reply_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Add a foreign key constraint for the reply giver
-- Create a table for reply givers
CREATE TABLE reply_givers (
    reply_giver_id INTEGER PRIMARY KEY,
    reply_giver_type VARCHAR(20) NOT NULL
);

-- Add a unique constraint to the reply_givers table
ALTER TABLE reply_givers
ADD CONSTRAINT uq_reply_givers_id_type UNIQUE (reply_giver_id, reply_giver_type);


-- Add a foreign key constraint for the reply giver
ALTER TABLE discussion
ADD CONSTRAINT fk_reply_giver
FOREIGN KEY (reply_giver_id, reply_giver_type) 
REFERENCES reply_givers(reply_giver_id, reply_giver_type);



ALTER TABLE Lecture
ADD COLUMN videolink TEXT,
ADD COLUMN pdflink  TEXT;

ALTER TABLE exam_section DROP COLUMN question_id;
ALTER TABLE exam_section 
ADD COLUMN course_id INTEGER,
ADD CONSTRAINT fk_course_id FOREIGN KEY (course_id) REFERENCES courses(id); 

--asif shuru maybe (er aager kisu baad ase kina dekhish)

 insert into exam_section (exam_topic,course_id) values ('BST',2);

 CREATE TABLE exam (
    id SERIAL PRIMARY KEY,
    examSectionId INTEGER,
    CONSTRAINT fk_examSectionId FOREIGN KEY (examSectionId) REFERENCES exam_section(id)
);

insert into choice (option_text,question_id) values ('logn',1);
insert into choice (option_text,question_id) values ('n',1);
insert into choice (option_text,question_id) values ('1',1);
insert into choice (option_text,question_id) values ('n^3',1);

insert into question (question_statement,exam_id) values ('What is the time complexity of BST deletion?',1);

CREATE OR REPLACE FUNCTION is_question_exists_by_statement(
    p_question_statement VARCHAR
) RETURNS BOOLEAN
AS $$
DECLARE
    v_count INTEGER;
BEGIN
    -- Check if the question exists in the database
    SELECT COUNT(*)
    INTO v_count
    FROM questions
    WHERE question_statement = p_question_statement;

    -- Return true if the count is greater than 0, indicating the question exists
    RETURN v_count > 0;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN FALSE; -- Question not found
    WHEN OTHERS THEN
        -- Handle exceptions as needed, such as logging errors
        RETURN FALSE; -- Return false in case of errors
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION insert_question(
    p_question_statement VARCHAR
) RETURNS INTEGER 
AS $$
DECLARE
    v_question_id INTEGER;
BEGIN
    -- Check if the question already exists
    IF is_question_exists_by_statement(p_question_statement) THEN
        -- If the question already exists, return -1 to indicate failure
        RETURN -1;
    ELSE
        -- Insert the question if it doesn't exist
        INSERT INTO questions (question_statement)
        VALUES (p_question_statement)
        RETURNING id INTO v_question_id;
        
        -- Return the ID of the inserted question
        RETURN v_question_id;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions if any
        RETURN -1; -- Return -1 to indicate failure
END;
$$ LANGUAGE plpgsql;

INSERT INTO TEACHER (TEACHER_NAME,PASSWORD_HASH) VALUES ('DR.ALAM',3);
INSERT INTO TEACHER (TEACHER_ID,TEACHER_NAME,PASSWORD_HASH) VALUES (4,'DR.KHAN',4);
INSERT INTO TEACHER (TEACHER_NAME,PASSWORD_HASH) VALUES ('DR.HASAN',6);
INSERT INTO teacher (
        teacher_name,
        teacher_proficiency,
        teacher_birth_date,password_hash
    )
VALUES ( 'Mr.Smith', 'Science', '1995-06-15','7'),
    ('Miss Nahar', 'Language', '1977-07-22','8');

insert into choice (option_text,question_id) values ('logn',2),('n',2),('1',2),('n^3',2);
ALTER TABLE question
ADD COLUMN question_ans VARCHAR(255); -- Adjust the data type and size according to your requirements
UPDATE question
SET question_ans = 'logn'
WHERE id = 1;
UPDATE question
SET question_ans = 'logn'
WHERE id = 2;

CREATE TABLE student_ans (
    student_id INT,
    question_id INT,
    submitted_ans_text TEXT,
    PRIMARY KEY (student_id, question_id),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (question_id) REFERENCES question(id)
);


--eta uncommited still
CREATE OR REPLACE FUNCTION calculate_result(
    p_exam_id IN NUMBER
) RETURN NUMBER IS
    v_total_questions NUMBER;
    v_correct_answers NUMBER := 0;
BEGIN
    -- Get the total number of questions for the exam
    SELECT COUNT(*) INTO v_total_questions
    FROM question
    WHERE exam_id = p_exam_id;

    -- Loop through each question to compare the submitted answer with the correct answer
    FOR question_rec IN (SELECT id, question_ans FROM question WHERE exam_id = p_exam_id) LOOP
        -- Retrieve the submitted answer for the current question
        DECLARE
            v_submitted_answer VARCHAR2(100); -- Assuming the data type for submitted answers
        BEGIN
            -- Retrieve the submitted answer from the table where the user's answers are stored
            -- Replace 'submitted_answers_table' with the actual name of the table where user's answers are stored
            SELECT answer INTO v_submitted_answer
            FROM submitted_answers_table
            WHERE question_id = question_rec.id;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- Handle the case where the user has not submitted an answer for this question
                v_submitted_answer := NULL;
        END;

        -- Compare the submitted answer with the correct answer
        IF question_rec.question_ans = v_submitted_answer THEN
            v_correct_answers := v_correct_answers + 1;
        END IF;
    END LOOP;

    -- Calculate the percentage of correct answers
    RETURN (v_correct_answers / v_total_questions) * 100;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions as needed
        RETURN -1; -- Return -1 to indicate failure
END;
/

--aro lagbe aage ei exam dise kina sheta check. 
--asif shesh
